<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Orbital Physics Simulation</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 400vh; /* 400vh height */
        background: linear-gradient(
          to bottom,
          #000000 0%,
          /* Space */ #020b1e 20%,
          /* Thermosphere */ #0f4c81 60%,
          /* Atmosphere */ #87ceeb 100% /* Earth surface */
        );
        overflow-x: hidden;
        font-family: "Courier New", Courier, monospace;
      }

      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none; /* Let clicks pass through for parallax logic if needed */
      }

      .ui-panel {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 280px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        color: rgba(255, 255, 255, 0.9);
        font-size: 12px;
        z-index: 10;
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
      }

      .ui-panel h2 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: #fff;
        text-transform: uppercase;
        letter-spacing: 1px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding-bottom: 5px;
      }

      .stat-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
      }

      .stat-value {
        font-weight: bold;
        color: #4facfe;
      }
    </style>
  </head>
  <body>
    <canvas id="simCanvas"></canvas>

    <div class="ui-panel">
      <h2>Orbital Telemetry</h2>
      <div class="stat-row">
        <span>Active Asteroids:</span>
        <span id="asteroid-count" class="stat-value">0</span>
      </div>
      <div class="stat-row">
        <span>Stars Visible:</span>
        <span id="star-count" class="stat-value">500</span>
      </div>
      <div class="stat-row">
        <span>FPS:</span>
        <span id="fps-counter" class="stat-value">60</span>
      </div>
      <div class="stat-row">
        <span>Scroll Progress:</span>
        <span id="scroll-ui" class="stat-value">0%</span>
      </div>
      <div style="margin-top: 10px; font-size: 10px; opacity: 0.6">
        PARABOLIC TRAJECTORY ENABLED<br />
        ABLATION MODEL ACTIVE<br />
        ATMOSPHERIC DRAG: 0.995
      </div>
    </div>

    <script>
      const canvas = document.getElementById("simCanvas");
      const ctx = canvas.getContext("2d");
      const countDisplay = document.getElementById("asteroid-count");
      const fpsDisplay = document.getElementById("fps-counter");
      const scrollDisplay = document.getElementById("scroll-ui");

      // State
      let width, height, docHeight;
      let mouseX = 0;
      let scrollY = 0;

      // Configuration
      const STAR_COUNT = 500;
      const ASTEROID_SPAWN_INTERVAL = 500; // ms
      const DRAG = 0.995;
      const GRAVITY = 0.03;
      const ABLATION_THRESHOLD_RATIO = 0.25; // 25% of page
      const MELT_RATE = 0.05; // Slightly adjusted for visibility visual feel, will respect logic

      // Objects
      const stars = [];
      const asteroids = [];

      // Utilities
      const random = (min, max) => Math.random() * (max - min) + min;

      class Star {
        constructor() {
          this.reset();
          // Distribute vertically across the ENTIRE document height, not just viewport
          this.y = random(0, docHeight);
        }

        reset() {
          this.x = random(0, width);
          this.y = random(0, docHeight);
          this.z = random(0.1, 1.0); // Depth for parallax

          // Size Variation policy
          const isLarge = Math.random() < 0.05;
          if (isLarge) {
            this.baseRadius = random(2.0, 3.0);
            this.alphaMult = 1.0;
          } else {
            this.baseRadius = random(0.5, 1.5);
            this.alphaMult = 0.8;
          }

          this.radius = this.baseRadius;
          this.twinklePhase = random(0, Math.PI * 2);
          this.twinkleSpeed = random(0.02, 0.08);
          this.baseAlpha = random(0.3, 0.8) * this.alphaMult;
        }

        update() {
          this.twinklePhase += this.twinkleSpeed;
        }

        draw(ctx, scrollY) {
          // Parallax offset computation
          // We want them to move slightly based on mouse X
          const parallaxX = (mouseX - width / 2) * this.z * 0.02;

          // Screen position: absolute Y - scrollY
          const screenY = this.y - scrollY;

          // Visibility Horizon Check: > 74% of total doc height
          // Note: using docHeight * 0.74 as the fade start point
          const horizonY = docHeight * 0.74;

          let alpha = this.baseAlpha + Math.sin(this.twinklePhase) * 0.15;

          // Fade out if near horizon
          if (this.y > horizonY) {
            const fadeStart = horizonY;
            const fadeEnd = docHeight * 0.85; // Fully gone by 85%
            const dist = Math.max(0, this.y - fadeStart);
            const range = fadeEnd - fadeStart;
            const fadeFactor = 1 - Math.min(1, dist / range);
            alpha *= fadeFactor;
          }

          // Don't draw if off screen or fully invisible
          if (screenY < -10 || screenY > height + 10 || alpha <= 0) return;

          ctx.beginPath();
          ctx.arc(this.x + parallaxX, screenY, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.fill();
        }
      }

      class Asteroid {
        constructor() {
          const fromLeft = Math.random() > 0.5;

          // Position
          this.x = fromLeft ? -50 : width + 50;
          // Spawning in top 30% of VIEWPORT logic or DOC?
          // Spec says "y < height * 0.3". 'height' usually implies viewport in canvas context, but 'document.body.scrollHeight' is used for stars.
          // Assuming spawning relative to current viewport for visibility, OR top of Universe?
          // Spec: "Konum: Ekranın üst kısmından (y < height * 0.3)".
          // Let's spawn them relative to the scrolling 'viewport' top so user always sees them,
          // OR fixed at top of space? "Orbital simulation" usually implies top of the atmosphere.
          // I will spawn them at absolute Y = random(0, height * 0.3) + scrollY to effectively simulate "entering current view"
          // OR just random(0, height * 0.3) (Absolute Space Top).
          // "Orbital Physics" -> Falling from space. I will spawn them at absolute top (0 to 0.3*ViewportHeight) but tracking them in absolute coordinates.
          this.y = random(0, height * 0.3) + scrollY;

          this.radius = random(3.0, 6.0); // Starting size
          this.originalRadius = this.radius;

          // Angle & Velocity
          // Left: 0-15 deg. Right: 165-180 deg.
          let angleDeg;
          if (fromLeft) {
            angleDeg = random(0, 15);
          } else {
            angleDeg = random(165, 180);
          }
          const rad = angleDeg * (Math.PI / 180);
          const speed = random(4.0, 10.0);

          this.vx = Math.cos(rad) * speed;
          this.vy = Math.sin(rad) * speed;

          this.active = true;
          this.heat = 0; // For color
        }

        update() {
          if (!this.active) return;

          // Gravity
          this.vy += GRAVITY;

          // Drag
          this.vx *= DRAG;
          this.vy *= DRAG;

          // Position integration
          this.x += this.vx;
          this.y += this.vy;

          // Ablation / Heating
          const burnThreshold = docHeight * ABLATION_THRESHOLD_RATIO;
          if (this.y > burnThreshold) {
            // Heat increases as we go deeper
            const depth = this.y - burnThreshold;
            this.heat = Math.min(1, depth / (docHeight * 0.2)); // Max heat at +20% deep

            // Melt
            this.radius -= MELT_RATE * (1 + this.heat * 2);

            if (this.radius <= 0) {
              this.radius = 0;
              this.active = false;
            }
          }
        }

        draw(ctx, scrollY) {
          if (!this.active) return;

          const screenY = this.y - scrollY;

          // Do not draw if way off screen
          if (screenY < -100 || screenY > height + 100) return;

          // TAIL DRAWING
          // Tail is opposite to velocity
          const tailLen = (Math.abs(this.vx) + Math.abs(this.vy)) * 6; // Scale tail by speed
          const angle = Math.atan2(this.vy, this.vx);
          const tailAngle = angle + Math.PI; // Opposite direction

          // Two points perpendicular to velocity at the body
          const perpAngle = angle + Math.PI / 2;
          const r = this.radius;

          const p1x = this.x + Math.cos(perpAngle) * r;
          const p1y = this.y + Math.sin(perpAngle) * r - scrollY;

          const p2x = this.x + Math.cos(perpAngle + Math.PI) * r;
          const p2y = this.y + Math.sin(perpAngle + Math.PI) * r - scrollY;

          // Tip of the tail
          const tipX = this.x + Math.cos(tailAngle) * tailLen;
          const tipY = this.y + Math.sin(tailAngle) * tailLen - scrollY;

          // Color based on heat
          let colorStop1, colorStop2;
          if (this.heat < 0.3) {
            colorStop1 = "rgba(100, 200, 255, 0.8)"; // Blueish
            colorStop2 = "rgba(100, 200, 255, 0)";
          } else if (this.heat < 0.7) {
            colorStop1 = "rgba(255, 200, 50, 0.9)"; // Yellowish
            colorStop2 = "rgba(255, 100, 50, 0)";
          } else {
            colorStop1 = "rgba(255, 50, 50, 0.9)"; // Red-hot
            colorStop2 = "rgba(255, 0, 0, 0)";
          }

          const grad = ctx.createLinearGradient(this.x, screenY, tipX, tipY);
          grad.addColorStop(0, colorStop1);
          grad.addColorStop(1, colorStop2);

          ctx.beginPath();
          ctx.moveTo(p1x, p1y);
          ctx.lineTo(p2x, p2y);
          ctx.lineTo(tipX, tipY);
          ctx.closePath();
          ctx.fillStyle = grad;
          ctx.fill();

          // BODY
          ctx.beginPath();
          ctx.arc(this.x, screenY, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = "#fff";
          ctx.fill();
        }
      }

      // Main Loop
      let lastTime = 0;
      let spawnTimer = 0;

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        docHeight = document.body.scrollHeight;
        canvas.width = width;
        canvas.height = height;

        // Re-init stars if doc height changes significantly?
        // For now, let's keep them stable or they jump.
        // If we run out of stars at bottom because doc grew, that's fine for this demo.
      }

      function init() {
        resize();
        window.addEventListener("resize", resize);
        window.addEventListener("mousemove", (e) => {
          mouseX = e.clientX;
        });
        window.addEventListener("scroll", () => {
          scrollY = window.scrollY;
          scrollDisplay.innerText =
            Math.round((scrollY / (docHeight - height)) * 100) + "%";
        });

        // Populate Stars
        for (let i = 0; i < STAR_COUNT; i++) {
          stars.push(new Star());
        }

        requestAnimationFrame(animate);
      }

      function animate(time) {
        // Delta time calculation
        const deltaTime = time - lastTime;
        lastTime = time;

        // FPS Update (throttle)
        if (time % 500 < 20) {
          fpsDisplay.innerText = Math.round(1000 / deltaTime);
        }

        ctx.clearRect(0, 0, width, height);

        // Spawner
        if (time - spawnTimer > ASTEROID_SPAWN_INTERVAL) {
          asteroids.push(new Asteroid());
          spawnTimer = time;
        }

        // Update & Draw Stars
        stars.forEach((star) => {
          star.update();
          star.draw(ctx, scrollY);
        });

        // Update & Draw Asteroids
        // Reverse loop for removal
        for (let i = asteroids.length - 1; i >= 0; i--) {
          const a = asteroids[i];
          a.update();
          a.draw(ctx, scrollY);

          if (!a.active) {
            asteroids.splice(i, 1);
          }
        }

        countDisplay.innerText = asteroids.length;

        requestAnimationFrame(animate);
      }

      init();
    </script>
  </body>
</html>
